% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cotClass.R
\name{cotOptions}
\alias{cotOptions}
\title{Options available for the COT method}
\usage{
cotOptions(
  lambda = NULL,
  delta = NULL,
  penalty.function = "entropy",
  debias = TRUE,
  p = 2,
  cost = NULL,
  cost.online = "auto",
  balance.formula = NULL,
  grid.length = 7L,
  torch.optimizer = torch::optim_lbfgs,
  torch.scheduler = torch::lr_reduce_on_plateau,
  niter = 1000,
  nboot = 100L,
  tol = 1e-07,
  ...
)
}
\arguments{
\item{lambda}{The penalty parameter for the entropy penalized optimal transport. Default is NULL. Can be a single number or a set of numbers to try.}

\item{delta}{The bound for balancing functions if they are being used. Only available for biased entropy penalized optimal transport. Can be a single number or a set of numbers to try.}

\item{penalty.function}{The penalty to use for the optimal transport distances. Should be one of "entropy" or "L2".}

\item{debias}{Should debiased optimal transport be used? TRUE or FALSE. Only available for \code{penalty.function}="entropy".}

\item{p}{The power of the cost function to use for the cost.}

\item{cost}{A function to calculate the pairwise costs. Should take arguments \code{x1}, \code{x2}, and \code{p}. Default is NULL.}

\item{cost.online}{Should an online cost algorithm be used? One of "auto", "online", or "tensorized". "tensorized" is the offline option.}

\item{balance.formula}{Formula for the balancing functions.}

\item{grid.length}{The number of penalty parameters to explore in a grid search if none are provided in arguments \code{lambda} or \code{delta}.}

\item{torch.optimizer}{The torch optimizer to use for methods using debiased entropy penalized optimal transport.}

\item{torch.scheduler}{The scheduler for the optimizer}

\item{niter}{The number of iterations to run the solver}

\item{nboot}{The number of iterations for the bootstrap to select final penalty parameters.}

\item{tol}{The tolerance for convergence}

\item{...}{Arguments passed to the solvers. See details}
}
\value{
A list of class \code{cotOptions} with the following slots
\itemize{
\item \code{lambda}The penalty parameter for the optimal transport distance
\item \code{delta}The constraint for the balancing functions
\item \code{penalty.function}The penalty function to use
\item \code{debias}TRUE or FALSE if debiased optimal transport distances are used
\item \code{balance.formula}
\item \code{grid.length} The number of parameters to check in a grid search of best parameters
\item \code{p} The power of the cost function
\item \code{cost.online} Whether online costs are used
\item \code{cost} The user supplied cost function if supplied.
\item \code{torch.optimizer} The \code{torch} optimizer used for Sinkhorn Divergences
\item \code{torch.scheduler} The scheduler for the \code{torch} optimizer
\item \code{solver.options} The arguments to be passeed to the \code{torch.optimizer}
\item \code{scheduler.options} The arguments to be passeed to the \code{torch.scheduler}
\iterm \code{niter} The number of iterations to run the solver
\item \code{nboot} The number of bootstrap samples
\item \code{tol} The tolerance for convergence.
}
}
\description{
Options available for the COT method
}
\section{Solvers and distances}{
The function is setup to direct the COT optimizer to run three basic methods: debiased entropy penalized optimal transport (Sinkhorn Divergences), entropy penalized optimal transport (Sinkhorn Distances), or L2 penalized optimal transport. Each of these options utilizes a specific solver.
\subsection{Sinkhorn Distances}{

The optimal transport problem solved is \eqn{min_w OT_\lambda(w,b) } where \deqn{OT_\lambda(w,b) = \sum_{ij} C(x_i, x_j) P_{ij} + \lambda \sum_{ij} P_{ij}\log(P_{ij}),} such that the rows of the matrix \eqn{P_{ij}} sum to \eqn{w} and the columns sum to \eqn{b}. In this case \eqn{C(,)} is the cost between units i and j.

The solver for this distance is provided by \link[lbfgsb3c:lbfgsb3c]{lbfgsb3c()} and so arguments in dots are passed to the function. We can also supply balancing functions via the formula argument in \code{balance.formula} (see below).
}

\subsection{L2 OT Distances}{

In this case, the optimal transport problem is again \eqn{min_w OT_\lambda(w,b) } where \deqn{OT_\lambda(w,b) = \sum_{ij} C(x_i, x_j) P_{ij} + \frac{\lambda}{2} \sum_{ij} P_{ij}^2,}

The solver for this distance is provided by \link[osqp:osqp]{osqp()} and so arguments in dots are passed to the solver via that packages \link[osqp:osqpSettings]{osqpSettings()} function. We can also supply balancing functions via the formula argument in \code{balance.formula} (see below).
}

\subsection{Sinkhorn Divergences}{

The Sinkhorn Divergence solves \deqn{min_w OT_\lambda(w,b) - 0.5 OT_\lambda(w,w) - 0.5 * OT_\lambda(b,b).} The solver for this function uses the \code{torch} package in \code{R} and by default will use the LBFGS solver. Your desired \code{torch} optimizer can be passed via \code{torch.optimizer} with a scheduler passed via \code{torch.scheduler}. GPU support is available as detailed in the \code{torch} package. Additional arguments in \code{...} are passed as extra arguments to the \code{torch} optimizer and schedulers as appropriate.
}
}

\section{Function balancing}{
There may be certain functions of the covariates that we wish to balance within some tolerance, \eqn{\delta}. For these functions \eqn{B}, we will desire
\deqn{\frac{\sum_{i: Z_i = 0} w_i B(x_i) - \sum_{j: Z_j = 1} B(x_j)/n_1}{\sigma} \leq \delta}, where in this case we are targeting balance with the treatment group for the ATT. $\sigma$ is the pooled standard deviation prior to balancing. This is currently only available for \eqn{L_2} penalized distances and Sinkhorn Distances.
}

\section{Cost functions}{
The cost function specifies pairwise distances. If argument \code{cost} is NULL, the function will default to using \eqn{L_p^p} distances with a default \eqn{p = 2} supplied by the argument \code{p}.So for \code{p = 2}, the cost between units \eqn{x_i} and \eqn{x_j} will be \deqn{C(x_i, x_j) = \frac{1}{2} \| x_i - x_j \|_2^2.}
If \code{cost} is provided, it should be a function that takes arguments \code{x1}, \code{x2}, and \code{p}.
}

\examples{
opts <- cotOptions(lambda = 1e3, torch.optimizer = torch::optim_lbfgs)
opts <- cotOptions(lambda = NULL)
opts <- cotOptions(lambda = seq(0.1, 100, length.out = 7))
}
