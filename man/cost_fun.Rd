% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cost_functions.R
\name{cost_fun}
\alias{cost_fun}
\title{Calculate cost matrix for a given estimand}
\usage{
cost_fun(x, z, power = 2, metric = dist.metrics(), estimand = "ATE", ...)
}
\arguments{
\item{x}{An object of class `matrix`}

\item{z}{A treatment indicator with values in 0 and 1. Should be of class
`integer` or `vector`}

\item{power}{The power used to calculate the the cost matrix: \math{\{(x-y)^{power}\}^{(1/{power})}}}

\item{metric}{One of the values in [dist.metrics][dist.metrics()].}

\item{estimand}{The estimand desired for the weighting estimator. See details}

\item{...}{Arguments passed to the RKHS calculating function including
\itemize{
\item `kernel`, one of "RBF", "polynomial", "linear"
\item `rkhs.args` The arguments used to construct the kernel
\item 
}
`...` can also be used to handle extra arguments passed by mistake so that
an error is not thrown.}
}
\value{

}
\description{
Calculate cost matrix for a given estimand
}
\details{
If the estimand is "ATT" or "ATC", `cost_fun` will calculate 
the cost matrix where the rows are the control
and the columns are the treated. If "ATE" will calculate to cost matrices
with the first having the rows corresponding to the control individual and the
second having rows correspond to the treated individuals. For both matrices,
the columns will correspond to the full sample.
}
\examples{
n0 <- 100
n1 <- 55
d <- 5
x1 <- matrix(stats::rnorm(n1*d), n1, d)
x0 <- matrix(stats::rnorm(n0*d), n0, d)

x <- rbind(x0,x1)
z <- c(rep(0,n0), rep(1,n1))
power <- 2.0

# ATT
estimand <- "ATT"
metric <- "Lp"
cost_ATT <- cost_fun(x, z, power = power, metric = metric, estimand = estimand)
print(dim(cost_ATT))

# ATE
# gives two matrices between control and full sample and treated and full sample
# in a list
estimand <- "ATE"
cost_ATT <- cost_fun(x, z, power = power, metric = metric, estimand = estimand)
length(cost_ATT)
}
